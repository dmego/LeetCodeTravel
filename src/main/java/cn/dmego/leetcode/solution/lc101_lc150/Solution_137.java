package cn.dmego.leetcode.solution.lc101_lc150;

/**
 * 只出现一次的数字 II
 *
 * 给你一个整数数组 nums ，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次 。请你找出并返回那个只出现了一次的元素。
 *
 * @author dmego
 * @date 2022/10/11 10:54
 */
public class Solution_137 {

    // 解法一：使用 HashMap 统计所有数字出现的次数，然后遍历找到只出现一次的那个数字


    /**
     解法二：考虑数字的二进制形式，我们以整数 32 位来计算，统计每一位出现 1 的个数 m，
     因为数组中，只有一个元素出现 1 次，其余元素都出现 3 次，对于每一位：
        值为 1 ：如果该数是重复元素，那么统计时就会有 3 个 1；如果该数就是出现一次的元素，那么统计只会有一个 1
        值为 0：不管该数是重复还是唯一的那个元素，统计时，1 的个数都是 0
     于是，对于 m % 3, 取余数，只有两种结果。要么是 1， 要么是 0，而值为 1 表示，只出现一次的元素的该位数上是 1
     */
    public int singleNumber(int[] nums) {
        if (nums.length == 1) return nums[0];
        // 只出现一次的数字结果
        int res = 0;

        // 循环统计每一个数字的二进制表示的 32 位上值为 1 的个数
        for (int i = 0; i < 32; i++) {
            // 记录值为 1 的个数
            int count = 0;
            // 遍历每一个元素
            for (int j = 0; j < nums.length; j++) {
                /*
                 1. >> 左移表示将二进制向左移动，高位补 0， 低位溢出的移除。
                    nums[j] >> i, 也就是表示讲 数字 nums[j] 向左移动 i 位
                    也就是让 num[j] 的第 i 位出现在最左边的第一位
                 2. 对于按位与运算，X & 1 = 1， 说明 X 的左边第一位的值是 1
                 3. 于是 (nums[j] >> i) & 1 的计算结果就说明 nums[j]的二进制 在 i 位 上是否为 1
                 */
                if (((nums[j] >> i) & 1) == 1) {
                    // 如果 nums[j] 的二进制 在 i 位 上是为 1，则计数 + 1
                    count++;
                }
            }

            // 如果所以元素在 i 位上统计的 1 的个数和除以 3 余数是 1
            // 说明这个 1 在唯一的元素的 i 位 上，也就是 res 的 i 位上是 1
            if (count % 3 != 1) {
                /*
                  1. 既然知道了res 的 i 位上是 1，就需要给 res 的 i 位上赋值为 1
                  2. 1 << i 表示，把 1 右移 i 位，其结果的二进制的第 i 位，一定就是 1，可以理解为 前面左移操作的相反逻辑
                  3. 对于按位或，只要 0 | 0 = 0，其余运算结果都是 1，也就是说如果其中有一个是 1，那么运算(|)的结果一定是 1
                  4. res | (1 << i) 就表示，将 res 的 i 位赋值为 1
                 */
                res = res | (1 << i) ;
            }
        }
        // 最后 res 就是唯一的数字
        return res;
    }


    /*
     解法三：有限状态自动机
     按照解法二的思路，我们求解的原理还是统计数字二进制中个位上的1，然后除以 3 求余数
      求余的结果有三种：0 1 2，对于二进制输入 0，求余的结果等于 0
      对于二进制输入1, 求余的结果满足一定规律的状态流转：
        0 -> 1 -> 2 -> 0 -> 1 -> 2..
     对于一位的二进制输入，我们将 0 1 2 这三种状态使用两个二进制表示就是：
        00 -> 01 -> 10 -> 00 -> 01 -> 10 -> 00..

     假设现在有一个数组输入: [0, 1, 0, 0, 1, 1, 1], 肉眼看，很明显出现一次的一个数是 1
     我们从状态流转的角度来看，初始状态为 00：
        二进制输入 0: 00 -> (0) ==> 00
        二进制输入 1: 00 -> (1) ==> 01
        二进制输入 0: 01 -> (0) ==> 01
        二进制输入 1: 01 -> (1) ==> 10
        二进制输入 1: 10 -> (1) ==> 00
        二进制输入 1: 00 -> (1) ==> 01
     最后状态流转的结果是 01，因为这个状态是对 3 取余，并且只有一个出现一次的数，所以最后结果一定是在状态位的第一位上

     我们用两个标记来表示状态的二进制位：(two one), 例如 01 状态的 one 就是 1， two 就是 0
     我们可以发现 one 和 two 其实是不能同时为 1 的
     假设输入二进制标识为 n，当前的状态是 (two one), 我们观察上面状态流转, 对于下一个状态 (two`, one`) 的求解：
     如何求 one`
        if (two = 0) {
            if (n = 0) one` = one
            if (n = 1) one` = ~one
        }
        // 当 two = 1 时，
        if (two = 1) {
            one = 0
        }

        简化一下：one` = one ^ n & ~two
        解释：
          1 ^ 0 = 1, 1 ^ 1 = 0
          1 & ~1 = 0，0 & ~1 = 0
        ==>
          if (two = 0) 下面的两个分支求解就可以简化为 one ^ n
          if (two = 1) one 横等于 0，所以只需要在 & ~two 就行
          最后 one` = one ^ n & ~two

      如何求 two`
         two` 的结果其实和 one` 有关系
         if (one` = 0) {
                00 -> 0 = 00
                10 -> 0 = 10
                10 -> 1 = 00

            if (n = 0) two` = two
            if (n = 1) two` = ~two
         }
         if (one` = 1) {
             two = 0
         }

         简化为：two` = two ^ n & ~one`

        以上的求解是在一位二进制的情况下，使用了两位二进制的状态求解
        在 32 位整数情况下，也适用，也就是对于 32 位整数的每一位，都会按照这个思路来求解最后结果状态的 two 和 one
        因为 我们知道，对于每一位，最后的结果，只会在 0 和 1 之间，也就是状态位的 one 位
        所以最后 one 就像找到的唯一出现一次的数
     */
    public int singleNumber2(int[] nums) {
        int one = 0, two = 0;
        for (int n : nums) {
            one = (one ^ n) & ~two;
            two = (two ^ n) & ~one;
        }
        return one;
    }


}
